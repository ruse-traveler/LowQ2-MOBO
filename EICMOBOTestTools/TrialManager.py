# =============================================================================
## @file    TrialManager.py
#  @authors Derek Anderson
#  @date    09.19.2025
# -----------------------------------------------------------------------------
## @brief Class to generate commands and scripts to run
#    for a given trial.
# =============================================================================

import datetime
import pathlib
import re
import os
import subprocess

from EICMOBOTestTools import AnaGenerator
from EICMOBOTestTools import ConfigParser
from EICMOBOTestTools import FileManager
from EICMOBOTestTools import GeometryEditor
from EICMOBOTestTools import RecGenerator
from EICMOBOTestTools import SimGenerator

class TrialManager:
    """TrialManager

    A class to generate commands and scripts to be run
    for a given trial.
    """

    def __init__(self, run, par, ana, tag = None):
        """constructor accepting arguments

        Note that if no tag is provided, then
        one will be autogenerated based on
        start time.

        Args:
          run: runtime configuration file
          par: parameter configuration file
          ana: objectives configuration file
          tag: tag to use for trial
        """
        self.cfgRun  = ConfigParser.ReadJsonFile(run)
        self.cfgPar  = ConfigParser.ReadJsonFile(par)
        self.cfgAna  = ConfigParser.ReadJsonFile(ana)
        self.geoEdit = GeometryEditor(run)
        self.simGen  = SimGenerator(run)
        self.recGen  = RecGenerator(run)
        self.anaGen  = AnaGenerator(run, ana)
        self.tag     = self.__MakeTimeTag() if tag == None else tag

    def __MakeTimeTag(self):
       """MakeTimeTag

       Generates a tag based on current time.

       Returns:
         generated tag
       """
       time = str(datetime.datetime.now())
       time = re.sub(r'[.\-:\ ]', '', time)
       tag = f"AID2ETrial{time}"
       return tag

    def __DoGeometryEdits(self, params):
        """DoGeometryEdits

        Generate new geometry files.

        Args:
          params: dictionary of parameter names and current values (eg. from Ax)
        Returns:
          name of new epic config file
        """
        trialConfig = ""
        for par, value in params.items():
            cfg = self.cfgPar["parameters"][par]
            if cfg["stage"] != "sim":
                continue
            else:
                self.geoEdit.EditCompact(cfg, value, self.tag)
                trialConfig = self.geoEdit.EditConfig(cfg, self.tag)

        # return name of new config file
        return trialConfig

    def __SetRecoArgs(self, params):
        """SetRecoArgs

        Set updated reconstruction arguments.

        Args:
          params: dictionary of parameter names and current values (eg. from Ax)
        """
        self.recGen.ClearArgs()
        for par, value in params.items():

            # ignore parameters from earlier stages
            cfg = self.cfgPar["parameters"][par]
            if cfg["stage"] != "rec":
                continue
            else:
                self.recGen.AddParamToArgs(cfg, value)

    def MakeTrialScript(self, params):
        """MakeTrialScript

        Generate needed geometry files and script to run
        full sequence of trial.

        Args:
          params: dictionary of parameter names and current values (eg. from Ax)
        Returns:
          tuple of path to script and a dictionary of output files
          associated with each objective
        """

        # step 1: edit geometry files, set
        # reconstruction parameters
        trialCfg = self.__DoGeometryEdits(params)
        self.__SetRecoArgs(params)

        # create commands to set detector path, config
        cfgFile = FileManager.GetConfigFromPath(trialCfg)
        setInstall, setConfig = FileManager.MakeSetCommands(
            self.cfgRun["epic_setup"],
            cfgFile
        )
        commands = [setInstall, setConfig]

        # check for overlaps
        #   -- TODO should stop trial somehow if
        #      there are overlaps
        #commands.append(
        #    self.simGen.MakeOverlapCheckCommand()
        #)

        # step 2: generate relevant simulation,
        # reconstruction commands
        outFiles = dict()
        for inKey, inCfg in self.cfgRun["sim_input"].items():

            # if there are multiple steering files,
            # loop over each
            inLoc  = inCfg["location"]
            inType = inCfg["type"]
            for inSteer in os.listdir(inLoc):

                # only consider steering files
                # (which end in .py)
                isSteer = inSteer.endswith('.py')
                if not isSteer:
                    continue

                # generate command to run simulation
                commands.append(
                    self.simGen.MakeCommand(
                        self.tag,
                        inKey,
                        inLoc,
                        inSteer,
                        inType
                    )
                )

                # now generate command to run reconstruction
                commands.append(
                    self.recGen.MakeCommand(
                        self.tag,
                        inKey,
                        inSteer
                    )
                )

            # step 3: generate relevant merging/analysis commands
            #   -- FIXME it would be better to have some way to
            #      1st identify what needs to be merged and then
            #      only merge that
            doSimMerge, simMerged = self.anaGen.MakeMergeCommand(self.tag, inKey, "sim")
            doRecMerge, recMerged = self.anaGen.MakeMergeCommand(self.tag, inKey, "rec")
            commands.append(doSimMerge)
            commands.append(doRecMerge)

            # find objectives requiring current input
            for anaKey, anaCfg in self.cfgAna["objectives"].items():

                # skip if objective is not an analysis
                if anaCfg["stage"] != "ana":
                    continue

                # skip if not needing input 
                if anaCfg["input"] != inKey:
                    continue

                # otherwise generate command to run analysis and
                # its output file
                command, outFile = self.anaGen.MakeCommand(self.tag,
                                                           inKey,
                                                           anaKey,
                                                           simMerged,
                                                           recMerged)

                # append analysis command and output file
                # to appropriate lists/dictionaries
                commands.append(command)
                outFiles[anaKey] = outFile

        # make sure run directory
        # exists for trial
        runDir = self.cfgRun["run_path"] + "/" + self.tag
        FileManager.MakeDir(runDir)

        # construct script name
        runScript = FileManager.MakeScriptName(self.tag)
        runPath   = runDir + "/" + runScript

        # compose script
        with open(runPath, 'w') as script:
            script.write("#!/bin/bash\n\n")
            for command in commands:
                script.write(command + "\n\n")

        # make sure script can be run
        os.chmod(runPath, 0o777)

        # return path to script
        return runPath, outFiles

    def DoTrial(self, param):
        """DoTrial

        Carries out trial by generating the relevant
        script and then running it. For each objective
        run, current parameter values will be appended
        to an output text file.

        Note that extracting objectives depends on the
        individual analyses. That functionality is
        deferred to a separate interface module.

        Args:
          param: dictionary of parameters and their current values
        Returns:
          dictionary of output files
        """

        # create and run script
        script, outFiles = self.MakeTrialScript(param)
        subprocess.run([self.cfgRun["eic_shell"], "--", script])

        # write out values of parameters to
        # output file(s) for analysis later
        for anaKey, anaOut in outFiles.items():
            anaPath = pathlib.Path(anaOut)
            anaTxt  = anaPath.with_suffix('.txt')
            isFile  = os.path.isfile(anaTxt)
            with open(anaTxt, 'a+') as txt:
                for parKey, parVal in param.items():
                    if isFile:
                        txt.write("\n")
                    txt.write(f"{parVal}")

        # return relevant output files
        return outFiles

# end =========================================================================
